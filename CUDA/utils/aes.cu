#include <cuda_runtime.h>
#include <device_launch_parameters.h>
#include <cuda.h>

#include "aes.h"



__device__ unsigned char dob[256] =
{
	0x00,0x02,0x04,0x06,0x08,0x0a,0x0c,0x0e,0x10,0x12,0x14,0x16,0x18,0x1a,0x1c,0x1e,
	0x20,0x22,0x24,0x26,0x28,0x2a,0x2c,0x2e,0x30,0x32,0x34,0x36,0x38,0x3a,0x3c,0x3e,
	0x40,0x42,0x44,0x46,0x48,0x4a,0x4c,0x4e,0x50,0x52,0x54,0x56,0x58,0x5a,0x5c,0x5e,
	0x60,0x62,0x64,0x66,0x68,0x6a,0x6c,0x6e,0x70,0x72,0x74,0x76,0x78,0x7a,0x7c,0x7e,
	0x80,0x82,0x84,0x86,0x88,0x8a,0x8c,0x8e,0x90,0x92,0x94,0x96,0x98,0x9a,0x9c,0x9e,
	0xa0,0xa2,0xa4,0xa6,0xa8,0xaa,0xac,0xae,0xb0,0xb2,0xb4,0xb6,0xb8,0xba,0xbc,0xbe,
	0xc0,0xc2,0xc4,0xc6,0xc8,0xca,0xcc,0xce,0xd0,0xd2,0xd4,0xd6,0xd8,0xda,0xdc,0xde,
	0xe0,0xe2,0xe4,0xe6,0xe8,0xea,0xec,0xee,0xf0,0xf2,0xf4,0xf6,0xf8,0xfa,0xfc,0xfe,
	0x1b,0x19,0x1f,0x1d,0x13,0x11,0x17,0x15,0x0b,0x09,0x0f,0x0d,0x03,0x01,0x07,0x05,
	0x3b,0x39,0x3f,0x3d,0x33,0x31,0x37,0x35,0x2b,0x29,0x2f,0x2d,0x23,0x21,0x27,0x25,
	0x5b,0x59,0x5f,0x5d,0x53,0x51,0x57,0x55,0x4b,0x49,0x4f,0x4d,0x43,0x41,0x47,0x45,
	0x7b,0x79,0x7f,0x7d,0x73,0x71,0x77,0x75,0x6b,0x69,0x6f,0x6d,0x63,0x61,0x67,0x65,
	0x9b,0x99,0x9f,0x9d,0x93,0x91,0x97,0x95,0x8b,0x89,0x8f,0x8d,0x83,0x81,0x87,0x85,
	0xbb,0xb9,0xbf,0xbd,0xb3,0xb1,0xb7,0xb5,0xab,0xa9,0xaf,0xad,0xa3,0xa1,0xa7,0xa5,
	0xdb,0xd9,0xdf,0xdd,0xd3,0xd1,0xd7,0xd5,0xcb,0xc9,0xcf,0xcd,0xc3,0xc1,0xc7,0xc5,
	0xfb,0xf9,0xff,0xfd,0xf3,0xf1,0xf7,0xf5,0xeb,0xe9,0xef,0xed,0xe3,0xe1,0xe7,0xe5
};

__device__ unsigned char triple[256] ={
	0x00,0x03,0x06,0x05,0x0c,0x0f,0x0a,0x09,0x18,0x1b,0x1e,0x1d,0x14,0x17,0x12,0x11,
	0x30,0x33,0x36,0x35,0x3c,0x3f,0x3a,0x39,0x28,0x2b,0x2e,0x2d,0x24,0x27,0x22,0x21,
	0x60,0x63,0x66,0x65,0x6c,0x6f,0x6a,0x69,0x78,0x7b,0x7e,0x7d,0x74,0x77,0x72,0x71,
	0x50,0x53,0x56,0x55,0x5c,0x5f,0x5a,0x59,0x48,0x4b,0x4e,0x4d,0x44,0x47,0x42,0x41,
	0xc0,0xc3,0xc6,0xc5,0xcc,0xcf,0xca,0xc9,0xd8,0xdb,0xde,0xdd,0xd4,0xd7,0xd2,0xd1,
	0xf0,0xf3,0xf6,0xf5,0xfc,0xff,0xfa,0xf9,0xe8,0xeb,0xee,0xed,0xe4,0xe7,0xe2,0xe1,
	0xa0,0xa3,0xa6,0xa5,0xac,0xaf,0xaa,0xa9,0xb8,0xbb,0xbe,0xbd,0xb4,0xb7,0xb2,0xb1,
	0x90,0x93,0x96,0x95,0x9c,0x9f,0x9a,0x99,0x88,0x8b,0x8e,0x8d,0x84,0x87,0x82,0x81,
	0x9b,0x98,0x9d,0x9e,0x97,0x94,0x91,0x92,0x83,0x80,0x85,0x86,0x8f,0x8c,0x89,0x8a,
	0xab,0xa8,0xad,0xae,0xa7,0xa4,0xa1,0xa2,0xb3,0xb0,0xb5,0xb6,0xbf,0xbc,0xb9,0xba,
	0xfb,0xf8,0xfd,0xfe,0xf7,0xf4,0xf1,0xf2,0xe3,0xe0,0xe5,0xe6,0xef,0xec,0xe9,0xea,
	0xcb,0xc8,0xcd,0xce,0xc7,0xc4,0xc1,0xc2,0xd3,0xd0,0xd5,0xd6,0xdf,0xdc,0xd9,0xda,
	0x5b,0x58,0x5d,0x5e,0x57,0x54,0x51,0x52,0x43,0x40,0x45,0x46,0x4f,0x4c,0x49,0x4a,
	0x6b,0x68,0x6d,0x6e,0x67,0x64,0x61,0x62,0x73,0x70,0x75,0x76,0x7f,0x7c,0x79,0x7a,
	0x3b,0x38,0x3d,0x3e,0x37,0x34,0x31,0x32,0x23,0x20,0x25,0x26,0x2f,0x2c,0x29,0x2a,
	0x0b,0x08,0x0d,0x0e,0x07,0x04,0x01,0x02,0x13,0x10,0x15,0x16,0x1f,0x1c,0x19,0x1a
};

__device__ unsigned char IV[16]={
  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
};

__device__ void print_bytes(unsigned char* str, int len){
	for(int i=0;i<len;i++)
		printf("%02x",str[i]);
	printf("\n");
}


// encription function (the kernel)
__global__ void aes_encript(unsigned char *mat, unsigned char *result, unsigned char *sbox, unsigned char *keys, unsigned int width){
  int id = (blockDim.x * blockIdx.x + threadIdx.x) * 16;

  __shared__ unsigned char shared_sbox[256]; // the s-box matrix in shared memory
  __shared__ unsigned char shared_keys[176]; // the sub-keys in shared memory
  if (threadIdx.x == 0){
		for (int i = 0; i != 256; ++i){
			shared_sbox[i] = sbox[i];
			if (i < 176) shared_keys[i] = keys[i];
		}
	}
	__syncthreads(); // barrier
  short idx, c = 0;
	unsigned char iv_new[16];
	unsigned char temp[16];

	#pragma unroll
	for (int i = 0; i < 16; ++i){
		temp[i] = mat[id + i];
		iv_new[i]=IV[i];;
  }

  // build new initialization vector
  for (idx = 15; idx >= 0; idx--){
    short shift = (16 - (idx + 1)) * 8;
    unsigned char op1 = IV[idx];
    unsigned char op2 = ((id &(0xff << shift)) >> shift);
    iv_new[idx] = op1 + op2 + c;
    c = (iv_new[idx] > op1 && iv_new[idx] > op2) ? 0 : 1;
  }
  // AES algorithm
	xor_key(iv_new, shared_keys, 0);
  #pragma unroll
  for(int i = 1; i < 10; i++){
    byte_sub(iv_new,shared_sbox);
    shift_rows(iv_new);
    mix_columns(iv_new);
    xor_key(iv_new, shared_keys, i);
	}
  byte_sub(iv_new, shared_sbox);
  shift_rows(iv_new);
  xor_key(iv_new, shared_keys, 10);

  //XOR with plain block
  #pragma unroll
  for (int i = 0; i < 16; ++i){
    unsigned char res = iv_new[i] ^ temp[i];
	  iv_new[i] = res;
  }
  #pragma unroll
  for (int i = 0; i < 16; ++i)
    result[id + i] = iv_new[i];
	result[width] = 0x0;

}


// Key Addition Kernel
__device__ void xor_key(unsigned char *mat, unsigned char *key, const unsigned int &round){
	#pragma unroll
	for (int i = 0; i < 16; ++i)
		mat[i] ^= key[(16 * round) + i];
}

// byte substitution (S-Boxes)
__device__ void byte_sub(unsigned char *mat,unsigned char* s_sbox){
	#pragma unroll
	for (int i = 0; i < 16; ++i)
		mat[i] = s_sbox[mat[i]];

}

// Shift rows
__device__ void shift_rows(unsigned char *mat){
  int k,tmp;
  #pragma unroll
  for(int i = 1; i < 4; i++){
    for(int j = 0; j < i; j++){
      tmp = mat[i*4];
      for(k = 0; k < 3; k++)
        mat[i*4+k] = mat[i*4+k+1];
      mat[i*4+k] = tmp;
    }
  }
}

// Mix column
__device__ void mix_columns(unsigned char* text_mat){
  unsigned char b0, b1, b2, b3;
  unsigned char result[16];
  int i;
  #pragma unroll
	for (i = 0; i < 4; i ++){
		b0 = text_mat[i];
		b1 = text_mat[i + 4];
		b2 = text_mat[i + 8];
		b3 = text_mat[i + 12];
		result[i] = dob[b0] ^ triple[b1] ^ b2 ^ b3;
		result[i + 4] = b0 ^ dob[b1] ^ triple[b2] ^ b3;
		result[i + 8] = b0 ^ b1 ^ dob[b2] ^ triple[b3];
		result[i + 12] = triple[b0] ^ b1 ^ b2 ^ dob[b3];
	}
  #pragma unroll
  for(i = 0; i < 16; i++)
    text_mat[i]=result[i];
}

void build_subkeys(unsigned char* key,unsigned char* sub_keys, int totsize,int rounds){
  for(int i = 0; i < rounds; i++){
    if(i == 0){
      for(int j = 0; j < totsize; j++){
        sub_keys[j] = (key[j] == 0x0)?0x0:key[j];
      }
    }else{
      sub_keys[i*totsize] = (sub_keys[(i-1)*totsize]^(get_sbox_value(sub_keys[(i-1)*totsize+13]) ^rc[i-1]));
      sub_keys[i*totsize+1] = (sub_keys[(i-1)*totsize+1]^get_sbox_value(sub_keys[(i-1)*totsize+14]));
      sub_keys[i*totsize+2] = (sub_keys[(i-1)*totsize+2]^get_sbox_value(sub_keys[(i-1)*totsize+15]));
      sub_keys[i*totsize+3] = (sub_keys[(i-1)*totsize+3]^get_sbox_value(sub_keys[(i-1)*totsize+12]));

      for(int j = 4; j < totsize; j+=4){
        sub_keys[i*totsize+j] = (sub_keys[(i*totsize)+j-4]^sub_keys[((i-1)*totsize)+j]);
        sub_keys[i*totsize+(j+1)] = (sub_keys[(i*totsize)+j-3]^sub_keys[((i-1)*totsize)+j+1]);
        sub_keys[i*totsize+(j+2)] = (sub_keys[(i*totsize)+j-2]^sub_keys[((i-1)*totsize)+j+2]);
        sub_keys[i*totsize+(j+3)] = (sub_keys[(i*totsize)+j-1]^sub_keys[((i-1)*totsize)+j+3]);
      }
    }
  }
}
